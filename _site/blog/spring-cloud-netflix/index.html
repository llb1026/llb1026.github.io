<!DOCTYPE html>
<html lang="ko">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <title>JIYUN.ME | Spring Cloud Netflix 간단정리</title>
    
        
    <!-- Post info -->
    <meta property="og:site_name" content="JIYUN.ME">
    <meta property="og:type" content="website" /> 
    <meta property="og:url" content="http://localhost:4000/blog/spring-cloud-netflix/" />
    
    <meta property="og:image" content="http://localhost:4000/blog/spring-cloud-netflix/img/01_main.png">

    <!-- title -->
    <meta property="og:title" content="JIYUN.ME | Spring Cloud Netflix 간단정리">
    
    <!-- description -->
    <meta property="og:description" content="## Spring Cloud Netfix > Spring Cloud Netflix는 자동 환경 설정과 Spring Environment 및 다른 Spring 프로그래밍 모델 관념의 바인딩을 바탕으로 Spring Boot 어플리케이션을 위한 Netflix OSS (Open Source Software)..."/>
        
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/uikit.min.css">
    <link rel="stylesheet" href="/assets/css/uikit-width-ex.min.css">
    <link rel="stylesheet" href="/assets/css/ionicons.min.css">
    <link rel="stylesheet" href="/assets/css/owl.carousel.min.css">
    <link rel="stylesheet" href="/assets/css/font-awesome.css">
    <link rel="stylesheet" href="/assets/css/animations.css">
    <link rel="stylesheet" href="/assets/css/theme.css">
    <link rel="stylesheet" href="/assets/css/responsive.css">
    <link rel="stylesheet" href="/assets/css/toc.css">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <link rel="stylesheet" href="/assets/js/prettify/skins/github2.css">
    <link href="https://fonts.googleapis.com/css?family=Droid+Sans:400,700%7CLora:400,400i%7CShadows+Into+Light:400" rel="stylesheet" />
    <link rel="shortcut icon" href="/assets/img/favicon_2.ico">
    

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-96635380-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-96635380-1');
    </script>

</head>

    
    <body class="loading">
        

        <!-- NavBar Start -->
        <div class="tw-preloader">
            <div data-uk-spinner></div>
        </div>

        <!-- 
        <div class="header-container tw-header uk-dark">
         -->
        <div class="header-container tw-header tw-header-transparent uk-dark" style="background-color: rgba(255, 255, 255, 0.25);">
        
            <nav class="uk-navbar-container uk-flex-center" data-uk-navbar>

                <!-- NavBar Left Logo Start -->
                <div class="uk-navbar-left">
                    <div class="tw-logo">
                        <h3 class="site-name">
                            <a href="/">JIYUN.ME</a>
                        </h3>
                    </div>
                </div>
                <!-- NavBar Left Logo End -->

                <!-- NavBar Center Menu Start -->
                <div class="uk-navbar-center" id="top">
                    <ul class="tw-main-menu uk-visible@m">
                        <li class="menu-item">
                            <a href="/"  class="normal"  class="active">Home</a>
                        </li>
                        <li class="menu-item">
                            <a href="/projects"  >Projects</a>
                        </li>
                        <li class="menu-item">
                            <a href="/blog"  class="active" >Blog</a>
                        </li>
                        <!-- <li class="menu-item">
                            <a href="/guestbook"  >Guestbook</a>
                        </li> -->
                    </ul>
                </div>
                <!-- NavBar Center Menu End -->

                <!-- NavBar Right Menu Icon Start -->
                <div class="uk-navbar-right">
                    <div class="tw-header-meta">
                        <a class="mobile-menu uk-navbar-toggle uk-hidden@m" href="#" data-uk-toggle="target: #mobile-menu-modal"><i class="ion-navicon-round"></i></a>
                    </div>
                </div>
                <!-- NavBar Right Menu Icon End -->

                <!-- NavBar Right Menu List Start -->
                <div id="mobile-menu-modal" class="uk-modal-full" data-uk-modal>
                    <div class="uk-modal-dialog">
                        <button class="uk-modal-close-full" type="button" data-uk-close></button>
                        <div class="uk-light uk-height-viewport tw-mobile-modal uk-flex uk-flex-middle uk-flex-center" data-uk-scrollspy="target:>ul>li,>div>a; cls:uk-animation-slide-bottom-medium; delay: 150;">
                            <ul class="uk-nav-default" data-uk-nav>
                                <li class="uk-nav-default">
                                    <a href="/"  class="normal"  class="active">Home</a>
                                </li>
                                <li class="uk-nav-default">
                                    <a href="/projects"  >Projects</a>
                                </li>
                                <li class="uk-nav-default">
                                    <a href="/blog"  class="active" >Blog</a>
                                </li>
                                <!-- <li class="uk-nav-default">
                                    <a href="/guestbook"  >Guestbook</a>
                                </li> -->
                            </ul>

                            <div class="tw-socials tw-socials-minimal">
                                <a href="https://github.com/llb1026" target="_blank"><i class="uk-icon-button tw-margin fa fa-github"></i></a>
                                <a href="https://www.linkedin.com/in/jiyun-lee-b19a02153" target="_blank"><i class="uk-icon-button tw-margin fa fa-linkedin"></i></a>
                            </div>

                        </div>
                    </div>
                </div>
                <!-- NavBar Right Menu List End -->

            </nav>
        </div>
        <!-- NavBar End -->
    
        <!-- Content Start -->
        <main>
            <div class="main-container">

    
        <br /><br />
<section class="uk-section-normal uk-section-blog" style="padding-bottom: 0;">
    <div class="uk-container uk-container-small">
        <div data-uk-grid>
            <div class="content-area uk-width-expand">
                <article class="single post">
                    <div class="entry-post">
                        <div class="entry-cats tw-meta">
                            <p>tech-notes</p>
                        </div>
                        <!-- <h2 class="entry-title post-title">
                            <a href="#">Spring Cloud Netflix 간단정리</a>
                        </h2> -->
                        <div class="heading-title-article post-title">
                            <h2 class="title">Spring Cloud Netflix 간단정리</h2>
                        </div>
                        <div class="entry-date tw-meta">
                            <span></span>
                        </div>

                        <!-- Blog Content Start -->
                        <div class="post-article">

                            <!-- Title Image Start -->
                            <div class="entry-media uk-padding-small">
                                <div class="tw-thumbnail" data-uk-lightbox>
                                    <img src="img/01_main.png" alt="" />
                                    <div class="image-overlay">
                                        <a href="img/01_main.png"></a>
                                    </div>
                                </div>
                            </div>
                            <!-- Title Image End -->

                            <!-- Scroll Spy TOC Start -->
                            <div class="toc">
                                <a href="#top">&#x1F446; 맨 위로</a>
                                <ul><li><a href="#spring-cloud-netfix">Spring Cloud Netfix</a><ul><li><a href="#전제조건">전제조건</a></li></ul></li><li><a href="#eureka-as-service-discovery">Eureka as Service Discovery</a><ul><li><a href="#기존의-서비스-디스커버리">기존의 서비스 디스커버리</a></li><li><a href="#클라우드-기반-마이크로서비스-아키텍처에서의-서비스-디스커버리">클라우드 기반 마이크로서비스 아키텍처에서의 서비스 디스커버리</a></li><li><a href="#eureka-server-구성">Eureka Server 구성</a></li><li><a href="#인스턴스-구성">인스턴스 구성</a></li></ul></li><li><a href="#ribbon-as-client-side-load-balancing">Ribbon as Client Side Load Balancing</a><ul><li><a href="#서비스-디스커버리만으로-충분하지-않은-이유">서비스 디스커버리만으로 충분하지 않은 이유</a></li><li><a href="#클라이언트-부하-분산의-역할">클라이언트 부하 분산의 역할</a></li><li><a href="#resttemplate을-사용한-ribbon-구성">RestTemplate을 사용한 Ribbon 구성</a></li></ul></li><li><a href="#zuul-as-api-gateway">Zuul as API Gateway</a><ul><li><a href="#api-게이트웨이의-역할">API 게이트웨이의 역할</a></li><li><a href="#라우터-구성">라우터 구성</a></li><li><a href="#필터-구성r">필터 구성r</a></li></ul></li></ul>
                            </div>
                            <!-- Scroll Spy TOC End -->

                            <h2 id="spring-cloud-netfix">Spring Cloud Netfix</h2>

<blockquote>
  <p>Spring Cloud Netflix는 자동 환경 설정과 Spring Environment 및 다른 Spring 프로그래밍 모델 관념의 바인딩을 바탕으로 Spring Boot 어플리케이션을 위한 Netflix OSS (Open Source Software) 통합을 제공합니다. 몇 가지 간단한 어노테이션을 사용하여 어플리케이션 내부의 공통 패턴을 신속하게 사용하고 설정할 수 있습니다. 그리고 battle-test를 거친 Netflix 컴포넌트를 통해 대규모 분산 시스템을 구축할 수 있습니다. 제공되는 패턴에는 Service Discovery (Eureka), Circuit Breaker (Hystrix), Intelligent Routing (Zuul), 그리고 Client Side Load Balancing (Ribbon) 등을 제공합니다. <a href="https://spring.io/projects/spring-cloud-netflix#overview">출처</a></p>
</blockquote>

<h3 id="전제조건">전제조건</h3>
<p>여기에서는 아래와 같은 목표/니즈가 있는 <em>클라우드 환경</em>의 <em>MSA</em> 기반 시스템을 가정합니다.</p>

<ul>
  <li>적정 크기: 어플리케이션을 신속하게 변경하고 전체 어플리케이션의 전반적인 장애를 줄일 수 있도록 마이크로서비스 하나 당 한 가지 책임 영역에 집중함</li>
  <li>위치 투명성: 대고객 서비스에 영향을 주지 않고 마이크로서비스 인스턴스를 빠르게 추가/삭제할 수 있도록 인스턴스의 물리적 위치를 관리함</li>
  <li>회복성: 서비스에 문제가 발생했을 때 대고객 서비스에 영향을 최소화하기 위하여 장애가 발생한 인스턴스를 우회하고 ‘발리 실패’하게 함</li>
  <li>반복성: 새로운 마이크로서비스 인스턴스가 시작될 때마다 벼롣의 복잡한 매뉴얼 작업 없이 기존 인스턴스와 동일한 코드/구성으로 시작되도록 함</li>
  <li>확장성: 서비스 간 의존성을 최소화하면서 어플리케이션이 신속하게 확장할 수 있도록 비동기 프로세싱과 이벤트를 활용함</li>
</ul>

<p>이를 위해서 이론적으로 다음 6가지 마이크로서비스 패턴을 따릅니다.</p>

<ol>
  <li>핵심 개발 패턴 (core development patterns); 어플리케이션을 어떻게 <em>적정 크기</em>로 나눌 것인지</li>
  <li>라우팅 패턴 (routing patterns): 어플리케이션 간의 <em>위치 투명성</em>을 어떻게 보장할 것인지</li>
  <li>클라이언트 회복성 패턴 (client resiliency patterns): <em>회복성</em>을 어떻게 보장할 것인지</li>
  <li>보안 패턴 (security patterns): AAA (Authentication, Authorization, Accounts)를 어떻게 관리할 것인지</li>
  <li>로깅 및 추적 패턴 (logging and tracing patterns): 어떻게 어플리케이션을 디버깅하고 추적할 것인지</li>
  <li>빌드 및 배포 패턴 (build and deployment patterns): 어플리케이션의 <em>반복성</em>과 <em>확장성</em>을 어떻게 보장할 것인지</li>
</ol>

<p>여기서 정리할 Spring Cloud Netflix의 Eureka, Ribbon, Zuul, Hystrix는 아래와 같이 각각의 패턴에 매칭될 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Name</th>
      <th style="text-align: left">Patterns</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Zuul</td>
      <td style="text-align: left">라우팅 패턴, 보안 패턴, 로깅 및 추적 패턴</td>
    </tr>
    <tr>
      <td style="text-align: left">Eureka</td>
      <td style="text-align: left">라우팅 패턴</td>
    </tr>
    <tr>
      <td style="text-align: left">Ribbon</td>
      <td style="text-align: left">라우팅 패턴</td>
    </tr>
    <tr>
      <td style="text-align: left">Hystrix</td>
      <td style="text-align: left">클라이언트 회복성 패턴</td>
    </tr>
  </tbody>
</table>

<h2 id="eureka-as-service-discovery">Eureka as Service Discovery</h2>
<h3 id="기존의-서비스-디스커버리">기존의 서비스 디스커버리</h3>
<p>서비스 디스커버리의 역할은 크게 아래 2가지로 꼽을 수 있습니다.</p>

<ol>
  <li>마이크로서비스 인스턴스 (API Callee)의 물리적 주소를 클라이언트 (API Caller)에게 드러내지 않아야 한다</li>
  <li>어플리케이션의 회복성을 위해 정상적인 상태가 아닌 인스턴스는 가용 인스턴스 목록에서 제거해야 한다</li>
</ol>

<p>여기가지 보면 기존의 L4나 DNS를 사용해도 무방할 것으로 보입니다. 그러나 이는 클라우드 기반의 마이크로서비스 아키텍처에서 아래와 같은 한계점을 갖고 있습니다.</p>

<ul>
  <li>로드밸런서를 다중화한다고 해도, 여전히 SPOF(Single Point Of Failure, 단일 장애 지점)이 될 수 있다</li>
  <li>보통 상용 로드밸런서는 hot-swap 이중화를 지원한다 (active 한 대, stand-by 한 대)</li>
  <li>새로운 인스턴스의 추가/삭제 과정이 느리다 (자동화 X, 수작업 필요)</li>
  <li>새로운 인스턴스의 추가/삭제 시 위치 투명성 보장이 불투명해진다</li>
</ul>

<h3 id="클라우드-기반-마이크로서비스-아키텍처에서의-서비스-디스커버리">클라우드 기반 마이크로서비스 아키텍처에서의 서비스 디스커버리</h3>
<p>클라우드 기반의 MSA 환경에서는 아래 기능을 갖춘 서비스 디스커버리가 적합합니다.</p>

<ul>
  <li>기존 로드밸런서보다 고가용성을 보장한다 (서비스 디스커버리 클러스터 구축)</li>
  <li>기존 로드밸런서가 하던 부하 분산 역할도 당연히 수행한다</li>
  <li>서비스 디스커버리 클러스터의 각 노드는 마이크로서비스 인스턴스의 상태를 공유한다</li>
  <li>서비스 디스커버리는 각 인스턴스의 상태를 지속적으로 감지하며 특정 인스턴스가 정상적이지 않을 때 가용 서비스 목록에서 해당 인스턴스를 제거한다</li>
  <li>모든 마이크로서비스 인스턴스는 서비스 디스커버리의 가용 서비스 목록을 로컬에 캐싱해 가지고 있으며, 서비스 디스커버리가 죽었을 때 캐싱된 목록을 활용해 계속 서비스를 이어나갈 수 있도록 한다</li>
</ul>

<p>간단히 위 목록을 도식화한 그림은 아래와 같습니다.
(그림그림)</p>

<h3 id="eureka-server-구성">Eureka Server 구성</h3>
<p>기본적으로 아래의 3개 어플리케이션이 필요합니다.</p>

<ol>
  <li>서비스 디스커버리 노드가 될 Eureka Server 어플리케이션</li>
  <li>Eureka를 통해 API를 호출할 API Caller 어플리케이션 A</li>
  <li>A의 요청에 대해 응답을 줄 API Callee 어플리케이션 B</li>
</ol>

<p>Eureka Server 어플리케이션을 간단하게 만들어봅니다.</p>

<ul>
  <li>의존성 추가 (build.gradle 파일)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
	implementation ‘org.springframework.cloud:spring-cloud-starter-netflix-eureka-server’
}
</code></pre></div></div>

<ul>
  <li>Eureka Server 어노테이션 추가</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableEurekaServer</span>    <span class="c1">// 이 부분</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EurekaServerApplication</span> <span class="o">{</span>
	<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>구성 설정 (application.properties 파일)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server.port=8761    // Eureka Server가 listen할 포트
eureka.instance.hostname=eureka    // Eureka Server의 호스트명
eureka.client.registerWithEureka=false    // Eureka Server에 자기 자신을 등록하지 않겠다는 의미
eureka.client.fetchRegistry=false    // 레지스트리 정보를 로컬에 캐싱하지 않겠다는 의미
eureka.client.serviceUrl.defaultZone=http://${registry.host:localhohst}:${server.port}/eureka
</code></pre></div></div>

<p>여기가지 구성 후 어플리케이션을 실행시켜 <code class="language-plaintext highlighter-rouge">localhost:8761</code>로 접속하면 간단한 Eureka Server 대시보드를 확인할 수 있습니다.
지금은 Eureka Server에 등록된 인스턴스가 없기 떄문에 빈 목록이 보입니다.</p>

<h3 id="인스턴스-구성">인스턴스 구성</h3>
<p>서비스 디스커버리에 등록할 API Caller, API Callee 어플리케이션을 만들어봅니다.</p>

<ul>
  <li>의존성 추가 (build.gradle 파일)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
	implementation ‘org.springframework.cloud:spring-cloud-starter-netflix-eureka-client’
}
</code></pre></div></div>

<ul>
  <li>인스턴스 등록 어노테이션 추가</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDiscoveryClient</span>    <span class="c1">// 이 부분</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApiCalleeApplication</span> <span class="o">{</span>
	<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>구성 설정 (application.properties 파일)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring.application.name=apicallee    // 서비스 디스커버리에 등록할 인스턴스의 논리적 이름
eureka.instance.preferIpAddress=true    // 인스턴스 이름 대신 IP주소를 등록하겠다는 의미
eureka.client.registerWithEureka=true    // Eureka Server에 자기 자신을 등록하겠다는 의미
eureka.client.serviceUrl.defaultZone=http://${registry.host:localhohst}:${server.port}/eureka
</code></pre></div></div>

<blockquote>
  <p>Eureka Server에 등록하는 인스턴스 식별자로는 ApplicationID와 InstanceID가 있습니다. ApplicationID는 인스턴스의 그룹을 의미하며, 위 프로퍼티 파일에서 명시한 spring.application.name입니다. InstanceID는 동일한 인스턴스가 여러 개 떠 있을 때, 각 인스턴스를 구분하는 임의의 숫자입니다.</p>
</blockquote>

<blockquote>
  <p>인스턴스의 논리적 이름 대신 IP주소를 등록하는 이유는 컨테이너 기반 (e.g. Docker) 배포 시 컨테이너가 DNS 엔트리가 없는 임의로 생성된 호스트명을 부여받아 시작하기 때문에, API Caller가 API Callee의 위치를 정상적으로 찾지 못합니다. 이를 방지하기 위해 항상 <code class="language-plaintext highlighter-rouge">eureka.instance.preferIpAddress=true</code>로 설정해두는 편이 적절하다고 합니다.</p>
</blockquote>

<p>이렇게 인스턴스가 Eureka Server에 등록되면 Eureka Server는 지속적인 health check를 통해 인스턴스의 상태를 가용 인스턴스 목록에 업데이트할 것입니다. 보통 Eureka Server에 등록된 인스턴스는 기본옵션 30초마다 자신의 상태를 Eureka Server에 알리며, 이 주기는 변경 가능합니다.</p>

<h2 id="ribbon-as-client-side-load-balancing">Ribbon as Client Side Load Balancing</h2>
<h3 id="서비스-디스커버리만으로-충분하지-않은-이유">서비스 디스커버리만으로 충분하지 않은 이유</h3>
<p>Eureka Server만 있다고 가정하면, 모든 API 요청은 Eureka Server를 통하게 되어 Eureka Server가 새로운 병목 지점이 될 수 있습니다. 서비스 디스커버리 의존성을 줄이기 위해 클라이언트 부하 분산이라는 방법을 사용할 수 있으며, 여기에 Ribbon이 활용됩니다.</p>

<h3 id="클라이언트-부하-분산의-역할">클라이언트 부하 분산의 역할</h3>
<ul>
  <li>서비스 디스커버리의 가용 인스턴스 목록을 캐싱하여 각 마이크로서비스 인스턴스 로컬에 저장한다</li>
  <li>어떤 인스턴스가 API를 호출할 때 먼저 로컬에 캐싱된 인스턴스 목록을 참조한다</li>
  <li>일반적으로 클라이언트 측 캐싱은 Round-Robbin 알고리즘을 사용해 API 호출을 여러 인스턴스로 분산한다</li>
  <li>주기적으로 서비스 디스커버리에 접속해 로컬 캐시를 업데이트한다</li>
</ul>

<p>클라이언트 로드밸런서를 추가한 그림은 아래와 같습니다.
(그림그림)</p>

<h3 id="resttemplate을-사용한-ribbon-구성">RestTemplate을 사용한 Ribbon 구성</h3>
<p>Spring Cloud 초기에는 Ribbon이 RestTemplate 클래스를 지원했지만, 현재는 더이상 지원되지 않습니다.
따라서 RestTemplate에서 Ribbon을 사용하려면 <code class="language-plaintext highlighter-rouge">@LoadBalanced</code> 어노테이션을 직접 추가해줘야 합니다.
다른 대안은 Netflix Feign 클라이언트로 서비스를 호출하는 것인데, 후에 추가하도록 하겠습니다.</p>

<ul>
  <li>의존성 추가 (build.gradle 파일)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
	implementation ‘org.springframework.cloud:spring-cloud-starter-netflix-ribbon’
}
</code></pre></div></div>

<ul>
  <li>RestTemplate 정의</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@LoadBalanced</span>
<span class="nd">@Bean</span>
<span class="nc">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">()</span> <span class="o">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="nf">RestTemplate</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>클라이언트 로드밸런서 어노테이션 추가</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDiscoveryClient</span>
<span class="nd">@RibbonClient</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"apicallee"</span><span class="o">,</span> <span class="n">configuration</span> <span class="o">=</span> <span class="nc">RibbonConfiguration</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>    <span class="c1">// 이 부분</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApiCallerApplication</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="nd">@Autowired</span>
	<span class="nc">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>
	
	<span class="o">...</span>
	<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/ call/api"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">callApiB</span><span class="o">()</span> <span class="o">{</span>
		<span class="o">...</span>
		<span class="k">this</span><span class="o">.</span><span class="na">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"http://apicallee/answer"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>    <span class="c1">// 위 RibbonClient 어노테이션에서 명시한 목적지를 서비스 디스커버리에서 검색 후 요청</span>
	<span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위의 간단한 예시에서 API Caller 역할을 하는 어플리케이션 A에 <code class="language-plaintext highlighter-rouge">/call/api</code>로 요청이 들어오면 어플리케이션 A는 API Callee 역할의 어플리케이션 B <code class="language-plaintext highlighter-rouge">/answer</code>로 요청을 보내는데, 요청을 보낼 목적지인 어플리케이션 B의 주소를 Eureka Server에 등록된 가용 인스턴스 목록에서 어플리케이션 B의 이름인 <code class="language-plaintext highlighter-rouge">apicallee</code>를 검색해 찾아냅니다.</p>

<h2 id="zuul-as-api-gateway">Zuul as API Gateway</h2>
<h3 id="api-게이트웨이의-역할">API 게이트웨이의 역할</h3>
<p>API 호출에 대한 <em>보안</em>과 <em>로깅</em> 등을 트래킹하기 위해 각 요청에 대한 필터와 라우터 역할을 하는 API 게이트웨이가 필요합니다.</p>

<p>만약 API 게이트웨이가 없이 보안, 로깅, 사용자 추적 등을 각 마이크로서비스 인스턴스에서 제각각 구현하게 된다면 일관성이 떨어지고 인스턴스 간의 의존성이 더 복잡해질 수 있습니다.</p>

<p>마이크로서비스 아키텍처에서 API 게이트웨이는 아래와 같은 역할을 수행합니다.</p>

<ul>
  <li>하나의 entry point URL 뒤에 모든 서비스를 배치하고, 서비스 디스커버리를 이용해 모든 호출을 실제 인스턴스로 매핑한다</li>
  <li>API 게이트웨이를 경유하는 모든 호출에 고유한 ID를 삽입한다</li>
  <li>호출 시 생성된 ID를 응답에도 삽입해 요청에 회신한다</li>
  <li>정적/동적 라우팅을 지원한다</li>
  <li>호출에 대한 인증(authentication)과 인가(authorization)을 처리한다</li>
  <li>호출 로그와 이에 따른 지표를 수집한다</li>
</ul>

<p>앞서 서비스 디스커버리 부분에서 언급했던 것처럼, API 게이트웨이도 병목지점이 될 수 있습니다. 가능한 API 게이트웨이 코드를 간결하고 stateless하게 유지하여 쉽게 다중화할 수 있어야 합니다.</p>

<h3 id="라우터-구성">라우터 구성</h3>

<ul>
  <li>의존성 추가 (build.gradle 파일)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dependencies {
	implementation ‘org.springframework.cloud:spring-cloud-starter-netflix-zuul’
}
</code></pre></div></div>

<ul>
  <li>API 게이트웨이 어노테이션 추가</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableDiscoveryClient</span>
<span class="nd">@EnableZuulProxy</span>    <span class="c1">// 이 부분</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ZuulApplication</span> <span class="o">{</span>
	<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>구성 설정 (application.properties 파일)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server.port=8762
eureka.instance.hostname=zuul
eureka.client.registerWithEureka=true
eureka.client.fetchRegistry=false
eureka.client.serviceUrl.defaultZone=http://${registry.host:localhohst}:${server.port}/eureka
</code></pre></div></div>

<p>이제 Eureka Server, API Caller 어플리케이션, API Callee 어플리케이션, 그리고 Zuul 어플리케이션을 실행한 후 <code class="language-plaintext highlighter-rouge">localhost:8762/actuator/routes</code>로 접속해보면 서비스 디스커버리에 의해 zuul이 라우팅할 수 있는 API 목록을 확인할 수 있습니다.</p>

<h3 id="필터-구성r">필터 구성r</h3>


                        </div>
                        <!-- Blog Content Start -->
                    </div>
                </article>
            </div>
        </div>
    </div>
</section>

<!-- Pagination Start -->
<section class="uk-section uk-section-small">
    <div class="uk-container uk-container-small">
        <div class="tw-portfolio-nav uk-flex uk-flex-between uk-flex-middle">
            
            <div class="nav-prev tw-meta">
                <a href="../how-transactional-works/">
                    <i class="ion-ios-arrow-left"></i>
                    <span>Prev</span>
                </a>
            </div>
            
            <div class="nav-link">
                <a href="/blog">
                    <i class="ion-grid"></i>
                </a>
            </div>
            
            <div class="nav-next tw-meta">
                <a href="../mariadb-spatial-functions/">
                    <span>Next</span>
                    <i class="ion-ios-arrow-right"></i>
                </a>
            </div>
            
        </div>
    </div>
</section>
<!-- Pagination End -->


<script>
    function getTOCNodes(master) {
        var nodes = Array.prototype.slice.call(master.getElementsByTagName("*"), 0);
        var tocNodes = nodes.filter(function(elem) {
            return elem.tagName == "A";
        });
        return tocNodes;
    }
    function getHeaderNodes(master) {
        var nodes = Array.prototype.slice.call(master.getElementsByTagName("*"), 0);
        var headerNodes = nodes.filter(function(elem) {
            return elem.tagName == "H1" || elem.tagName == "H2" || elem.tagName == "H3";
        });
        return headerNodes;
    }
  
    var title = document.getElementsByClassName("post-title")[0];
    var titleY = window.pageYOffset + title.getBoundingClientRect().top;
    
    var article = document.getElementsByClassName("post-article")[0];
    var articleY = window.pageYOffset + article.getBoundingClientRect().top;
  
    var toc = document.getElementsByClassName("toc")[0];
  
    var headerNodes = getHeaderNodes(article);
    var tocNodes = getTOCNodes(toc);
  
    var before = undefined;
  
    document.addEventListener('scroll', function(e) {
        if (window.scrollY >= articleY - 60) {
            toc.style.cssText = "position: fixed; top: 60px;";
        }
        else {
            toc.style.cssText = "";
        }
    
        var current = headerNodes.filter(function(header) {
            var headerY = window.pageYOffset + header.getBoundingClientRect().top;
            return window.scrollY >= headerY - 200;
        });
  
        if (current.length > 0) {
            current = current[current.length-1];
    
            var currentA = tocNodes.filter(function(tocNode) {
                return tocNode.innerHTML == current.innerHTML;
            })
            
            currentA = currentA[0];
            if (currentA) {
                if (before == undefined) before = currentA;
        
                if (before != currentA) {
                    before.classList.remove("toc-active");
                    before = currentA;
                }
        
                currentA.classList.add("toc-active");
            }
            else {
                if (before) 
                    before.classList.remove("toc-active");
            }
        }
        else {
            if (before) 
                before.classList.remove("toc-active");
        }
    }, false);
</script>

    
    
</div>


        </main>
        <!-- Content End -->
      
        <footer class="uk-section uk-padding-remove-vertical uk-light">
    <div class="footer-area footer-small">
        <div class="uk-container">
            <div class="uk-flex-middle uk-child-width-1-3" data-uk-grid>
                <div class="tw-element tw-socials tw-no-bg with-hover">
                    <a href="https://github.com/llb1026" target="_blank"><i class="uk-icon-button tw-margin fa fa-github"></i></a>
                    <a href="https://www.linkedin.com/in/jiyun-lee-b19a02153" target="_blank"><i class="uk-icon-button tw-margin fa fa-linkedin"></i></a>
                </div>
                <div class="uk-text-center copyright">
                    © JIYUN.ME
                </div>
                <div class="uk-text-right">
                    <a href="" data-uk-scroll>Top &nbsp;&nbsp;<i class="ion-ios-arrow-up"></i></a>
                </div>
            </div>
        </div>
    </div>
</footer>

   
        <script src="/assets/js/jquery-3.2.0.min.js"></script>
        <script src="/assets/js/jquery.easypiechart.min.js"></script>
        <script src="/assets/js/uikit.min.js"></script>
        <script src="/assets/js/uikit-icons.min.js"></script>
        <script src="/assets/js/isotope.pkgd.min.js"></script>
        <script src="/assets/js/owl.carousel.min.js"></script>
        <script src="/assets/js/theme.js"></script>
        

    </body>
</html>
